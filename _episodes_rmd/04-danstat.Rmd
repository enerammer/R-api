---
title: "What about danstat?"
teaching: 30
exercises: 15
output: 
  html_document:
    df_print: paged
objectives:
- "Use a package to do the API-calls to Statistics Denmark"
- "Connect to Statistics Denmark, and extract data"
- "Create a list of lists to control the variables to be extracted"
- "Using the danstat package"

keypoints: 
- "Larger services often provide packages to make it easier to use their API"

source: Rmd
questions:
- "Is there an easier way to access Statistics Denmark"

---

```{r setup, include = F, echo=F}
source("../bin/chunk-options.R")
knitr_fig_path("03-")
source("../bin/download_data.R")
library(remotes)
remotes::install_github("cran/danstat")
library(danstat)
library(tidyverse)
```

Please note: These pages are autogenerated. Some of the API-calls may fail during
that process. We are figuring out what to do about it, but please excuse us 
for any red errors on the pages for the time being.


## Is there an easier way?

Many larger online services provide packages for easier access to their APIs.

Popular services might not have to do this, because enthusiasts write packages
themselves.

A package called `danstat` is available, and makes it easier to extract data from
Statistics Denmark.


## The danstat package/library

Previously we retrieved at table with demographic data from Statistics Denmark.

How can we get that table using the danstat package?

Before using the library, we will need to install it:

```{r how-to-install-danstat, eval=F}
install.packages("danstat")
```

Some installations of R may have problems installing it. In that case, try this:
```{r alternative-danstat-install, eval =F}
install.packages("remotes")
library(remotes)
remotes:install_github("cran/danstat")
```

After installation, we load the library using the library function. And then 
we can access the functions included in the library:

The danstat package contain four functions, equivalent to the four endpoints
we discussed earlier.

The get_subjects() function sends a request to the Statistics Denmark API, asking
for a list of the subjects. The information is returned to our script, and the
get_subjects() function presents us with a dataframe containing the information.

```{r get-subjects}
library(danstat)
subjects <- get_subjects()
subjects
```


We get the 13 major subjects from Statistics Denmark we have seen before.
As before, each of them have sub-subjects.

If we want to take a closer look at the 
subdivisions of a given subject, we use the get_subjects() function again,
this time specifying which subject we are interested in:

Let us try to get the sub-subjects from the subject 1 - containing information
about populations and elections:

```{r get-sub-subjects}
sub_subjects <- get_subjects(subjects = 1)
sub_subjects
```








The result is a bit complicated. The column "subjects" in the resulting dataframe
contains another dataframe. We access it like we normally would access a 
column in a dataframe:

```{r show-sub-sub-subjects}
sub_subjects$subjects
```

Those sub-subjects have their own subjects! Lets get to the bottom of this, and
use 2401, Population and population projections as an example:

```{r even-more-subjects}
sub_sub_subjects <- get_subjects("3401")
sub_sub_subjects$subjects
```
Now we are at the bottom. We can see in the column "hasSubjects" that there 
are no sub_sub_sub_subjects. 

The hierarchy is:
1 Population and elections
| 
3401	Population 
|
20021	Population figures

The final sub_sub_subject contains a number of tables, that actually 
contains the data we are looking for.

get_subjects is able to retrieve all the sub, sub-sub and sub-sub-sub-jects in
one go. The result is a bit confusing and difficult to navigate.

Remember that the initial result was a dataframe containing another dataframe.
If we go all the way to the bottom, we will get a dataframe, containing several
dataframes, each of those containing several dataframes. 

We recommend that you do not try it, but this is how it is done:
```{r lots-of-subjects}
lots_of_subjects <- get_subjects(1, recursive = T, include_tables = T)
```

The "recursive = T" parameter means that get_subjects will retrieve 
the subjects of the subjects, and then the subjects of those subjects.

## Which datatables exists?

But we ended up with a sub_sub_subject, 

*20021	Population figures*

How do we find out which tables exists in this subject?

The get_tables() function returns a dataframe with information about the 
tables available for a given subject.


```{r get-tables}
tables <- get_tables(subjects="20021")
tables
```

We get at lot of information here. The id identifies the table, text gives a 
description of the table that humans can understand. When the table was last
updated and the first and last period that the table contains data for.

In the variables column, we get information on what kind of data is stored in 
the table.

Before we pull out the data, we need to know which variables are available
in the table. We do this with this function:

```{r get-metadata}
metadata <- get_table_metadata("FOLK1A", variables_only = T)
metadata
```

There is a lot of other metadata in the tables, including the phone number to 
the staffmember at Statistics Denmark that is responsible for maintaining the
table. We are only interested in the variables, which is why we add the 
parameter "variables_only = T".


What kind of values can the individual datapoints take?

```{r get-values}
metadata %>% 
  slice(4) %>% 
  pull(values)
```

We use the slice function from tidyverse to pull out the fourth row of the 
dataframe, and the pull-function to pull out the values in the values
column.

The same trick can be done for the other fields in the table:

```{r municipalites}
metadata %>% 
  slice(1) %>% 
  pull(values) %>% 
  .[[1]] %>% 
  head
```
Here we see the individual municipalities in Denmark. 

Now we are almost ready to pull out the actual data!

But first!

## Which variables do we want?

We need to specify which variables we want in our answer. Do we want 
the total population for all municipalities in Denmark? Or just a few?
Do we want the total population, or do we want it broken down by sex.

These variables, and the values of them, need to be specified when we 
pull the data from Statistics Denmark.

We also need to provide that information in a specific way.

If we want data for all municipalites, we want to pull the variable 
"OMRÅDE" from the list of variables.

Therefore we need to give the function an argument containing both
the information that we want the population data broken down by "OMRÅDE", and 
that we want all values of "OMRÅDE".

As before, we need to specify what we want using a list. 
Let us make our first list:

```{r first-list}
list(code = "OMRÅDE", values = NA)
```
  
This list have to components. One called "code", and one called "values".
Code have the content "OMRÅDE", specifying that we want the variable in the 
data from Statistics Denmark calld "OMRÅDE".

"values" has the content "NA". We use "NA", when we want to specify that we
want all the "OMRÅDE". If we only wanted a specific municipality, we could 
instead specify it instead of writing "NA".

Let us assume that we also want to break down the data based on marriage status.

That information is stored in the variable "CIVILSTAND".

And above, we saw that we had the following values in that variable:
```{r pulling-values}
metadata %>% 
  slice(4) %>% 
  pull(values)
```

A value for the total population is probably not that interesting, if we 
pull all the individual values for "Never married" etc.

We can now make another list:
```{r civilstand-list}
  list(code = "CIVILSTAND", values = c("U", "G", "E", "F"))
```

Here the "values" part is a vector containing the values we want to pull out 
for that variable.

It might be interesting to take a look at how the population changes over time.

In that case we need to pull out data from the "Tid" variable.

That would look like this:
```{r tid-list}
list(code = "Tid", values = NA)
```


If we want to pull data broken down by all three variables, we need to provide a
list, containing three lists. 

We do that using this code:


```{r list-of-lists}
variables <- list(list(code = "OMRÅDE", values = NA),
                  list(code = "CIVILSTAND", values = c("U", "G", "E", "F")),
                  list(code = "Tid", values = NA)
              )
variables
```

And now, finally, we are ready to get the data!

```{r getting-data}
data <- get_data(table_id = "FOLK1A", variables = variables)
```
It takes a short moment. But now we have a dataframe containing the data we 
requested:

```{r head-of-data}
head(data)
```

This procedure will work for all the tables from Statistics Denmark!

The data is nicely formatted and ready to use. Almost.

Before we do anything else, let us save the data.
```{r write-data-hidden, echo = F}
write_csv2(data, "../data/SD_data.csv")
```
```{r write-data-shown, eval = F}
write_csv2(data, "data/SD_data.csv")
```

{% include links.md %}